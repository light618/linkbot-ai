# 技术方案重新梳理

## 🎯 原始方案回顾

### 方案演进历程

#### 第一阶段：纯 live-im-proxy 方案
```mermaid
用户手动输入秘钥 → live-im-proxy → 监听+回复
```
**问题**：用户需要手动输入秘钥、room_id，体验不佳，不可行 ❌

#### 第二阶段：OAuth + live-im-proxy 增强版（正确方案）
```mermaid
用户扫码授权 → 获取access_token → live-im-proxy → 监听+回复
```
**核心思路**：
1. 通过抖音OAuth获取用户的 `access_token`
2. 将 `access_token` 传给 `live-im-proxy`
3. `live-im-proxy` 使用这个token监听直播间WebSocket
4. 处理事件并自动回复

#### 第三阶段：误入歧途 - 全用官方接口
**错误理解**：认为所有功能都用官方REST API
**问题**：官方接口能力有限，跑不通 ❌

## ✅ 正确的方案（回到第二阶段）

### live-im-proxy 的核心作用

#### 1. WebSocket 实时监听
- 官方只提供 `im_room` 能力（需要单独申请，成功率低）
- `live-im-proxy` 通过协议分析实现WebSocket监听
- 实时接收直播间评论、点赞、关注等事件

#### 2. 协议解析和转发
- 解析抖音内部消息协议
- 转换为标准事件格式
- 推送到后端处理

#### 3. 自动回复
- 接收AI生成的回复
- 通过协议发送回复消息
- 无需要官方API

### OAuth 的作用（只用于获取token）

#### 第一步：用户扫码授权
```go
// 前端：引导用户扫码
GET /proxy/oauth/douyin

// 抖音OAuth页面
用户扫码 → 确认授权

// 回调
GET /proxy/oauth/callback?code=xxx

// 换取token
POST https://open.douyin.com/oauth/access_token/
```

#### 第二步：保存access_token
```go
// 保存到数据库
{
  "account_id": "账号ID",
  "access_token": "用户授权的token",
  "refresh_token": "...",
  "expires_at": "过期时间"
}
```

#### 第三步：传给live-im-proxy
```go
// 启动live-im-proxy时传入token
live-im-proxy.Start(access_token)
```

## 🔍 live-im-proxy 实现原理

### WebSocket 连接
```go
// live-im-proxy 内部实现
func connectWebSocket(accessToken, roomID string) {
    // 使用token连接抖音直播间WebSocket
    ws := dial("wss://live.douyin.com/webcast/im/push/v2/")
    
    // 认证
    auth(accessToken)
    
    // 监听事件
    for event := range ws.Messages {
        // 解析抖音协议
        parseMessage(event)
        
        // 转发事件
        sendToPipeline(event)
    }
}
```

### 协议解析
- 抖音使用内部协议（可能基于Protobuf）
- `live-im-proxy` 需要逆向分析协议
- 解析评论、点赞、关注等消息

### 发送回复
- 构造符合抖音协议的消息
- 通过WebSocket发送
- 显示为直播间弹幕/回复

## 📊 方案对比

| 方案 | OAuth授权 | 监听方式 | 回复方式 | 稳定性 | 合规性 |
|------|-----------|---------|---------|--------|--------|
| 纯官方接口 | ✅ 需要 | REST轮询 | 官方API | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| live-im-proxy | ✅ 需要 | WebSocket协议 | 协议发送 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| OAuth+live-im | ✅ 提供 | WebSocket协议 | 协议发送 | ⭐⭐⭐⭐ | ⭐⭐⭐ |

## 🎯 最终方案确认

### 架构设计
```
用户前端
  ↓ 扫码授权
抖音OAuth
  ↓ 返回access_token
后端API (保存token)
  ↓ 启动服务时传入token
live-im-proxy (核心引擎)
  ↓ 使用token连接WebSocket
抖音直播间
  ↓ 实时事件推送
live-im-proxy (协议解析)
  ↓ 标准化事件
后端Pipeline
  ↓ 调用AI生成回复
live-im-proxy (协议发送)
  ↓ 回复消息
抖音直播间
```

### 关键技术点

#### 1. OAuth只用于获取token ✅
- 不依赖其他官方API能力
- 只需要基础的用户授权
- 获取到的token给live-im-proxy使用

#### 2. live-im-proxy负责监听+回复 ✅
- 使用协议方式连接WebSocket
- 实时接收和发送消息
- 不受官方API能力限制

#### 3. AI处理在中间层 ✅
- 接收到事件后，调用Coze AI分析
- 生成智能回复
- 通过live-im-proxy发送

## ⚠️ 风险和注意事项

### 1. 协议变更风险
- 抖音可能更新内部协议
- live-im-proxy需要跟随更新
- 保持代码维护

### 2. 账号风险
- 频繁发送可能被限流
- 需要控制发送频率
- 实现智能限流机制

### 3. 合规性
- 遵守抖音平台规则
- 不发送垃圾消息
- 提供人工介入机制

## 🔧 实现要点

### 修改Go代码
```go
// 不再调用官方评论API
// 改用live-im-proxy的WebSocket监听

func (d *DouyinChannel) Start(accessToken string) error {
    // 使用传入的token
    d.accessToken = accessToken
    
    // 连接WebSocket（live-im-proxy实现）
    return d.connectWebSocket()
}
```

### 前端授权流程
```typescript
// 1. 引导用户授权
const authURL = await getDouyinAuthURL()

// 2. 用户扫码授权
showQRCode(authURL)

// 3. 获取token
const { access_token } = await callback(authCode)

// 4. 传给live-im-proxy启动监听
await startProxy(access_token)
```

## 🎯 下一步行动

### 立即执行
1. ✅ 确认方案：OAuth获取token + live-im-proxy监听回复
2. 🔧 修改代码：移除官方API调用，改用WebSocket监听
3. 🔧 完善授权流程：获取token后启动live-im-proxy

### 技术调研
4. 📚 深入研究live-im-proxy的协议实现
5. 📚 了解如何传入access_token
6. 📚 测试WebSocket连接稳定性

### 风险评估
7. ⚠️ 评估协议变更风险
8. ⚠️ 评估账号安全风险
9. ⚠️ 制定应对措施

## 💡 总结

主公，您的理解完全正确！

**原始方案**：live-im-proxy（协议方式监听回复）
**增强点**：通过OAuth获取token，改善用户体验
**错误理解**：我一度认为全部用官方接口
**正确方案**：OAuth获取token + live-im-proxy实现监听回复

**核心价值**：
- OAuth：改善用户体验，不需要手动输入秘钥
- live-im-proxy：实现官方接口不支持的功能

现在需要的是深入研究 live-im-proxy 如何工作，以及如何传入 access_token。

---

**创建时间**：2025-10-27  
**状态**：方案确认
